# RPGHost

## Описание
Мы нашли самый свободный хостинг в мире. Говорят, в /flag.txt можно даже найти флаг. [Ссылка](http://rpghost.mctf.online/)

К таску был приложен архив с исходным кодом из папки src.

## Принцип работы сервиса
Сервис представляет собой файлохранилище. Пользователь может загрузить несколько файлов или zip архив, 
после чего выбрать, какие файлы он хочет сохранить (подтвердить их), и получить на них прямые ссылки. 
При этом сервер запрещает получение папок и 
[симлинков](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0), 
читая метаданные запрашиваемого файла.

## Описание уязвимости
Нам нужно прочитать файл /flag.txt. Этого можно добиться с помощью загрузки архива с симлинком, 
указывающим на `../../../../../flag.txt`. Но сервер не даст нам прочитать файл по ссылке, 
если увидит, что `StoredFileMetadata.isLink == true`.

При генерации id для файла при его подтверждении используется `UUID.randomUUID()`, который имеет достаточно большой диапазон 
результатов, чтобы не беспокоиться о возможных коллизиях. Но если бы он совпал, то сервер перезаписал бы уже существующий 
файл, и позволил бы скачивать новый файл под тем же id.

Сервер использует кэш для хранения двух вещей: содержимого файлов и метаданных файлов. При этом 
есть две детали:
1. Данные помещаются в кэш при запросе содержимого/метаданных, но не при загрузке файла.
2. Данные в кэше содержимого и в кэше метаданных имеют разное время устаревания. Метаданные живут 
в течение 5 минут, а содержимое файла - в течение 1 минуты.

Таким образом, если загрузить и подтвердить нормальный файл под определенным id, скачать его, чтобы заполнить кэш, 
подождать минуту (но не больше пяти), загрузить архив с симлинком, подтвердить симлинк под тем же id, а затем скачать его, 
то сервер достанет метаданные о файле из кэша, где `isLink == false`, но так как кэш содержимого уже устарел, он 
прочитает его заново и вернет содержимое файла, на который ссылается симлинк.

Но как заставить сервер перезаписать изначальный файл? При подтверждении файла фронт отправляет запрос вида
```
POST http://rpghost.mctf.online/api/confirm

{"tmpId": "(uuid, который вернул сервер при загрузке файла)"}
```

В StoredFile.kt можно увидеть, что этот класс имеет следующую структуру:
```
data class StoredFile(val id: UUID = UUID.randomUUID(), val tmpId: UUID)
```

При отправке запроса поля из json переносятся в поля этого класса, а после подтверждения он же возвращается пользователю. 
Поле `id`, которое содержит id, под которым будет доступен файл, генерируется автоматически при создании класса. 
Но ничто не мешает нам переопределить его в json:
```
POST http://rpghost.mctf.online/api/confirm

{"tmpId": "(uuid, который вернул сервер при загрузке файла)", "id": "(uuid, под которым мы хотим сохранить файл)"}
```

Тогда мы сможем подтвердить оба файла под одним id, который будет использоваться как ключ при кэшировании.

## Эксплуатация
Создадим симлинк, указывающий на `../../../../../flag.txt`, и запакуем его в архив `evil.zip`. Затем загрузим обычный файл 
в `/api/uploadFiles` и подтвердим через `/api/confirm`. Запишем id из ответа confirm, получим файл через `/get/{id}` и 
подождем минуту. Загрузим `evil.zip` в `/api/uploadZip` и подтвердим наш симлинк в `/api/confirm`, но добавим поле `id` с 
таким же значением, как в предыдущем ответе confirm. Вызовем `/get/{id}` ещё раз, и получим содержимое /flag.txt.